
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000005d4  00000000  00000000  00000054  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .debug_aranges 00000020  00000000  00000000  00000628  2**0
                  CONTENTS, READONLY, DEBUGGING
  2 .debug_pubnames 0000003a  00000000  00000000  00000648  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_info   00000201  00000000  00000000  00000682  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_abbrev 0000014c  00000000  00000000  00000883  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_line   0000062d  00000000  00000000  000009cf  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_frame  00000040  00000000  00000000  00000ffc  2**2
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_str    000000e9  00000000  00000000  0000103c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    000001ee  00000000  00000000  00001125  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_ranges 00000048  00000000  00000000  00001313  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 72 00 	jmp	0xe4	; 0xe4 <__ctors_end>
   4:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
   8:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
   c:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  10:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  14:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  18:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  1c:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  20:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  24:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  28:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  2c:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  30:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  34:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  38:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  3c:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  40:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  44:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  48:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  4c:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  50:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  54:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  58:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  5c:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  60:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  64:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  68:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  6c:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  70:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  74:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  78:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  7c:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  80:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  84:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  88:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  8c:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  90:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  94:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  98:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  9c:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  a0:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  a4:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  a8:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  ac:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  b0:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  b4:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  b8:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  bc:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  c0:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  c4:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  c8:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  cc:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  d0:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  d4:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  d8:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  dc:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>
  e0:	0c 94 7c 00 	jmp	0xf8	; 0xf8 <__bad_interrupt>

000000e4 <__ctors_end>:
  e4:	11 24       	eor	r1, r1
  e6:	1f be       	out	0x3f, r1	; 63
  e8:	cf ef       	ldi	r28, 0xFF	; 255
  ea:	d1 e2       	ldi	r29, 0x21	; 33
  ec:	de bf       	out	0x3e, r29	; 62
  ee:	cd bf       	out	0x3d, r28	; 61
  f0:	0e 94 a8 00 	call	0x150	; 0x150 <main>
  f4:	0c 94 e8 02 	jmp	0x5d0	; 0x5d0 <_exit>

000000f8 <__bad_interrupt>:
  f8:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000fc <compute_duty_cycle>:

}


unsigned int compute_duty_cycle(unsigned int dc,char ix)
{
  fc:	fc 01       	movw	r30, r24
	
	if (ix == '1')
  fe:	61 33       	cpi	r22, 0x31	; 49
 100:	29 f4       	brne	.+10     	; 0x10c <compute_duty_cycle+0x10>
		return 	( ((ICR1 /100 ) * dc));
 102:	80 91 86 00 	lds	r24, 0x0086
 106:	90 91 87 00 	lds	r25, 0x0087
 10a:	14 c0       	rjmp	.+40     	; 0x134 <compute_duty_cycle+0x38>
	if (ix == '3')
 10c:	63 33       	cpi	r22, 0x33	; 51
 10e:	29 f4       	brne	.+10     	; 0x11a <compute_duty_cycle+0x1e>
		return 	( ((ICR3 /100 ) * dc));
 110:	80 91 96 00 	lds	r24, 0x0096
 114:	90 91 97 00 	lds	r25, 0x0097
 118:	0d c0       	rjmp	.+26     	; 0x134 <compute_duty_cycle+0x38>
	if(ix == '4')
 11a:	64 33       	cpi	r22, 0x34	; 52
 11c:	29 f4       	brne	.+10     	; 0x128 <compute_duty_cycle+0x2c>
		return 	( ((ICR4 /100 ) * dc));
 11e:	80 91 a6 00 	lds	r24, 0x00A6
 122:	90 91 a7 00 	lds	r25, 0x00A7
 126:	06 c0       	rjmp	.+12     	; 0x134 <compute_duty_cycle+0x38>
	if(ix == '5')
 128:	65 33       	cpi	r22, 0x35	; 53
 12a:	89 f4       	brne	.+34     	; 0x14e <compute_duty_cycle+0x52>
		return 	( ((ICR5 /100 ) * dc));
 12c:	80 91 26 01 	lds	r24, 0x0126
 130:	90 91 27 01 	lds	r25, 0x0127
 134:	64 e6       	ldi	r22, 0x64	; 100
 136:	70 e0       	ldi	r23, 0x00	; 0
 138:	0e 94 aa 02 	call	0x554	; 0x554 <__udivmodhi4>
 13c:	e6 9f       	mul	r30, r22
 13e:	90 01       	movw	r18, r0
 140:	e7 9f       	mul	r30, r23
 142:	30 0d       	add	r19, r0
 144:	f6 9f       	mul	r31, r22
 146:	30 0d       	add	r19, r0
 148:	11 24       	eor	r1, r1
}
 14a:	c9 01       	movw	r24, r18
 14c:	08 95       	ret
 14e:	08 95       	ret

00000150 <main>:
#define _tb(x,b) x^=b
#define bit(x) (1 << (x))
#include "PWM640.h"
int main(void)
{
	_sb(DDRE,bit(3));
 150:	6b 9a       	sbi	0x0d, 3	; 13
	_sb(DDRH,bit(6));
 152:	80 91 01 01 	lds	r24, 0x0101
 156:	80 64       	ori	r24, 0x40	; 64
 158:	80 93 01 01 	sts	0x0101, r24
	_sb(PORTH, bit(6));
 15c:	80 91 02 01 	lds	r24, 0x0102
 160:	80 64       	ori	r24, 0x40	; 64
 162:	80 93 02 01 	sts	0x0102, r24
	TCCR3A = 0xA8;
 166:	88 ea       	ldi	r24, 0xA8	; 168
 168:	80 93 90 00 	sts	0x0090, r24
	TCCR3B = 0x11;
 16c:	81 e1       	ldi	r24, 0x11	; 17
 16e:	80 93 91 00 	sts	0x0091, r24
	ICR3 = 737;
 172:	81 ee       	ldi	r24, 0xE1	; 225
 174:	92 e0       	ldi	r25, 0x02	; 2
 176:	90 93 97 00 	sts	0x0097, r25
 17a:	80 93 96 00 	sts	0x0096, r24
	while(1)
	{
		OCR3A = 700;
 17e:	4c eb       	ldi	r20, 0xBC	; 188
 180:	52 e0       	ldi	r21, 0x02	; 2
		_tb(PORTH, bit(6));
 182:	60 e4       	ldi	r22, 0x40	; 64
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 184:	20 e7       	ldi	r18, 0x70	; 112
 186:	31 e0       	ldi	r19, 0x01	; 1
	TCCR3A = 0xA8;
	TCCR3B = 0x11;
	ICR3 = 737;
	while(1)
	{
		OCR3A = 700;
 188:	50 93 99 00 	sts	0x0099, r21
 18c:	40 93 98 00 	sts	0x0098, r20
		_tb(PORTH, bit(6));
 190:	80 91 02 01 	lds	r24, 0x0102
 194:	86 27       	eor	r24, r22
 196:	80 93 02 01 	sts	0x0102, r24
 19a:	80 e5       	ldi	r24, 0x50	; 80
 19c:	93 ec       	ldi	r25, 0xC3	; 195
 19e:	f9 01       	movw	r30, r18
 1a0:	31 97       	sbiw	r30, 0x01	; 1
 1a2:	f1 f7       	brne	.-4      	; 0x1a0 <main+0x50>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 1a4:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 1a6:	d9 f7       	brne	.-10     	; 0x19e <main+0x4e>
 1a8:	ef cf       	rjmp	.-34     	; 0x188 <main+0x38>

000001aa <PWM>:
	CLEAR = 0,SET = 1, TOGGLE = 2
}DirectionBIT;


void PWM(char SELECT1 , char SELECT2 ,unsigned int f , unsigned int dc,enum DirectionBIT bit)
{
 1aa:	bf 92       	push	r11
 1ac:	cf 92       	push	r12
 1ae:	df 92       	push	r13
 1b0:	ef 92       	push	r14
 1b2:	ff 92       	push	r15
 1b4:	0f 93       	push	r16
 1b6:	1f 93       	push	r17
 1b8:	cf 93       	push	r28
 1ba:	df 93       	push	r29
 1bc:	b6 2e       	mov	r11, r22
 1be:	6a 01       	movw	r12, r20
 1c0:	e9 01       	movw	r28, r18
	char ix;
	char cy;
	unsigned int  frequency,duty_cycle;

	ix = toupper(SELECT1);
 1c2:	90 e0       	ldi	r25, 0x00	; 0
 1c4:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <toupper>
 1c8:	18 2f       	mov	r17, r24
	cy = toupper(SELECT2);
 1ca:	8b 2d       	mov	r24, r11
 1cc:	90 e0       	ldi	r25, 0x00	; 0
 1ce:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <toupper>
 1d2:	b8 2e       	mov	r11, r24

	frequency = (FCLK / (2*f) );	//1 is selected as presclar
 1d4:	cc 0c       	add	r12, r12
 1d6:	dd 1c       	adc	r13, r13
 1d8:	ee 24       	eor	r14, r14
 1da:	ff 24       	eor	r15, r15
 1dc:	60 e0       	ldi	r22, 0x00	; 0
 1de:	70 e0       	ldi	r23, 0x00	; 0
 1e0:	81 ee       	ldi	r24, 0xE1	; 225
 1e2:	90 e0       	ldi	r25, 0x00	; 0
 1e4:	a7 01       	movw	r20, r14
 1e6:	96 01       	movw	r18, r12
 1e8:	0e 94 be 02 	call	0x57c	; 0x57c <__udivmodsi4>

	if(ix == '1')
 1ec:	11 33       	cpi	r17, 0x31	; 49
 1ee:	09 f0       	breq	.+2      	; 0x1f2 <PWM+0x48>
 1f0:	6f c0       	rjmp	.+222    	; 0x2d0 <PWM+0x126>
	{

		ICR1 = frequency;
 1f2:	30 93 87 00 	sts	0x0087, r19
 1f6:	20 93 86 00 	sts	0x0086, r18
		duty_cycle = compute_duty_cycle(dc,ix);
 1fa:	ce 01       	movw	r24, r28
 1fc:	61 e3       	ldi	r22, 0x31	; 49
 1fe:	0e 94 7e 00 	call	0xfc	; 0xfc <compute_duty_cycle>
 202:	9c 01       	movw	r18, r24

		TCCR1A = 0xA8;
 204:	88 ea       	ldi	r24, 0xA8	; 168
 206:	80 93 80 00 	sts	0x0080, r24
		TCCR1B = 0x11;
 20a:	81 e1       	ldi	r24, 0x11	; 17
 20c:	80 93 81 00 	sts	0x0081, r24

		if(cy == 'A')
 210:	81 e4       	ldi	r24, 0x41	; 65
 212:	b8 16       	cp	r11, r24
 214:	f9 f4       	brne	.+62     	; 0x254 <PWM+0xaa>
		  {
		   SETBIT(DDRB,BIT(5));
 216:	25 9a       	sbi	0x04, 5	; 4
		   OCR1A = duty_cycle;
 218:	30 93 89 00 	sts	0x0089, r19
 21c:	20 93 88 00 	sts	0x0088, r18
		   SETBIT(DDRL,BIT(2));		   
 220:	80 91 0a 01 	lds	r24, 0x010A
 224:	84 60       	ori	r24, 0x04	; 4
 226:	80 93 0a 01 	sts	0x010A, r24
		   if (bit == CLEAR)
 22a:	00 23       	and	r16, r16
 22c:	21 f4       	brne	.+8      	; 0x236 <PWM+0x8c>
		   {
			   CLEARBIT(PORTL,BIT(2));
 22e:	80 91 0b 01 	lds	r24, 0x010B
 232:	8b 7f       	andi	r24, 0xFB	; 251
 234:	05 c0       	rjmp	.+10     	; 0x240 <PWM+0x96>
		   }
		   else if (bit == SET)
 236:	01 30       	cpi	r16, 0x01	; 1
 238:	31 f4       	brne	.+12     	; 0x246 <PWM+0x9c>
		   {
			   SETBIT(PORTL,BIT(2));
 23a:	80 91 0b 01 	lds	r24, 0x010B
 23e:	84 60       	ori	r24, 0x04	; 4
 240:	80 93 0b 01 	sts	0x010B, r24
 244:	7d c1       	rjmp	.+762    	; 0x540 <PWM+0x396>
		   }
		   else if (bit == TOGGLE)
 246:	02 30       	cpi	r16, 0x02	; 2
 248:	09 f0       	breq	.+2      	; 0x24c <PWM+0xa2>
 24a:	7a c1       	rjmp	.+756    	; 0x540 <PWM+0x396>
		   {
			   TOGGLEBIT(PORTL,BIT(2));
 24c:	80 91 0b 01 	lds	r24, 0x010B
 250:	94 e0       	ldi	r25, 0x04	; 4
 252:	1f c0       	rjmp	.+62     	; 0x292 <PWM+0xe8>
		   }
		  }		
		else if(cy == 'B')
 254:	82 e4       	ldi	r24, 0x42	; 66
 256:	b8 16       	cp	r11, r24
 258:	f1 f4       	brne	.+60     	; 0x296 <PWM+0xec>
		  {
		   SETBIT(DDRB,BIT(6));
 25a:	26 9a       	sbi	0x04, 6	; 4
		   OCR1B = duty_cycle;
 25c:	30 93 8b 00 	sts	0x008B, r19
 260:	20 93 8a 00 	sts	0x008A, r18
		   SETBIT(DDRL,BIT(6));
 264:	80 91 0a 01 	lds	r24, 0x010A
 268:	80 64       	ori	r24, 0x40	; 64
 26a:	80 93 0a 01 	sts	0x010A, r24
		   if (bit == CLEAR)
 26e:	00 23       	and	r16, r16
 270:	21 f4       	brne	.+8      	; 0x27a <PWM+0xd0>
		   {
			   CLEARBIT(PORTL,BIT(6));
 272:	80 91 0b 01 	lds	r24, 0x010B
 276:	8f 7b       	andi	r24, 0xBF	; 191
 278:	e3 cf       	rjmp	.-58     	; 0x240 <PWM+0x96>
		   }
		   else if (bit == SET)
 27a:	01 30       	cpi	r16, 0x01	; 1
 27c:	21 f4       	brne	.+8      	; 0x286 <PWM+0xdc>
		   {
			   SETBIT(PORTL,BIT(6));
 27e:	80 91 0b 01 	lds	r24, 0x010B
 282:	80 64       	ori	r24, 0x40	; 64
 284:	dd cf       	rjmp	.-70     	; 0x240 <PWM+0x96>
		   }
		   else if (bit == TOGGLE)
 286:	02 30       	cpi	r16, 0x02	; 2
 288:	09 f0       	breq	.+2      	; 0x28c <PWM+0xe2>
 28a:	5a c1       	rjmp	.+692    	; 0x540 <PWM+0x396>
		   {
			   TOGGLEBIT(PORTL,BIT(6));
 28c:	80 91 0b 01 	lds	r24, 0x010B
 290:	90 e4       	ldi	r25, 0x40	; 64
 292:	89 27       	eor	r24, r25
 294:	d5 cf       	rjmp	.-86     	; 0x240 <PWM+0x96>
		   }
		  }
		else
		  {
		   SETBIT(DDRB,BIT(7));
 296:	27 9a       	sbi	0x04, 7	; 4
		   OCR1C = duty_cycle;
 298:	30 93 8d 00 	sts	0x008D, r19
 29c:	20 93 8c 00 	sts	0x008C, r18
		   
		   		   SETBIT(DDRL,BIT(7));
 2a0:	80 91 0a 01 	lds	r24, 0x010A
 2a4:	80 68       	ori	r24, 0x80	; 128
 2a6:	80 93 0a 01 	sts	0x010A, r24
		   		   if (bit == CLEAR)
 2aa:	00 23       	and	r16, r16
 2ac:	21 f4       	brne	.+8      	; 0x2b6 <PWM+0x10c>
		   		   {
			   		   CLEARBIT(PORTL,BIT(7));
 2ae:	80 91 0b 01 	lds	r24, 0x010B
 2b2:	8f 77       	andi	r24, 0x7F	; 127
 2b4:	c5 cf       	rjmp	.-118    	; 0x240 <PWM+0x96>
		   		   }
		   		   else if (bit == SET)
 2b6:	01 30       	cpi	r16, 0x01	; 1
 2b8:	21 f4       	brne	.+8      	; 0x2c2 <PWM+0x118>
		   		   {
			   		   SETBIT(PORTL,BIT(7));
 2ba:	80 91 0b 01 	lds	r24, 0x010B
 2be:	80 68       	ori	r24, 0x80	; 128
 2c0:	bf cf       	rjmp	.-130    	; 0x240 <PWM+0x96>
		   		   }
		   		   else if (bit == TOGGLE)
 2c2:	02 30       	cpi	r16, 0x02	; 2
 2c4:	09 f0       	breq	.+2      	; 0x2c8 <PWM+0x11e>
 2c6:	3c c1       	rjmp	.+632    	; 0x540 <PWM+0x396>
		   		   {
			   		   TOGGLEBIT(PORTL,BIT(7));
 2c8:	80 91 0b 01 	lds	r24, 0x010B
 2cc:	80 58       	subi	r24, 0x80	; 128
 2ce:	b8 cf       	rjmp	.-144    	; 0x240 <PWM+0x96>
		   		   }
		  }	
	}

	if(ix == '3')
 2d0:	13 33       	cpi	r17, 0x33	; 51
 2d2:	09 f0       	breq	.+2      	; 0x2d6 <PWM+0x12c>
 2d4:	65 c0       	rjmp	.+202    	; 0x3a0 <PWM+0x1f6>
	{
		TCCR3A = 0xA8;
 2d6:	88 ea       	ldi	r24, 0xA8	; 168
 2d8:	80 93 90 00 	sts	0x0090, r24
		TCCR3B = 0x11;
 2dc:	81 e1       	ldi	r24, 0x11	; 17
 2de:	80 93 91 00 	sts	0x0091, r24
		
		ICR3 = frequency;
 2e2:	30 93 97 00 	sts	0x0097, r19
 2e6:	20 93 96 00 	sts	0x0096, r18
		duty_cycle = compute_duty_cycle(dc,ix);
 2ea:	ce 01       	movw	r24, r28
 2ec:	63 e3       	ldi	r22, 0x33	; 51
 2ee:	0e 94 7e 00 	call	0xfc	; 0xfc <compute_duty_cycle>
		
 		
		if(cy == 'A')
 2f2:	21 e4       	ldi	r18, 0x41	; 65
 2f4:	b2 16       	cp	r11, r18
 2f6:	01 f5       	brne	.+64     	; 0x338 <PWM+0x18e>
		  { 
			   SETBIT(DDRE,BIT(3));
 2f8:	6b 9a       	sbi	0x0d, 3	; 13
			   OCR3A = duty_cycle;
 2fa:	90 93 99 00 	sts	0x0099, r25
 2fe:	80 93 98 00 	sts	0x0098, r24
			   
			   	SETBIT(DDRH,BIT(6));
 302:	80 91 01 01 	lds	r24, 0x0101
 306:	80 64       	ori	r24, 0x40	; 64
 308:	80 93 01 01 	sts	0x0101, r24
			   	if (bit == CLEAR)
 30c:	00 23       	and	r16, r16
 30e:	21 f4       	brne	.+8      	; 0x318 <PWM+0x16e>
			   	{
				   	CLEARBIT(PORTH,BIT(6));
 310:	80 91 02 01 	lds	r24, 0x0102
 314:	8f 7b       	andi	r24, 0xBF	; 191
 316:	05 c0       	rjmp	.+10     	; 0x322 <PWM+0x178>
			   	}
			   	else if (bit == SET)
 318:	01 30       	cpi	r16, 0x01	; 1
 31a:	31 f4       	brne	.+12     	; 0x328 <PWM+0x17e>
			   	{
				   	SETBIT(PORTH,BIT(6));
 31c:	80 91 02 01 	lds	r24, 0x0102
 320:	80 64       	ori	r24, 0x40	; 64
 322:	80 93 02 01 	sts	0x0102, r24
 326:	0c c1       	rjmp	.+536    	; 0x540 <PWM+0x396>
			   	}
			   	else if (bit == TOGGLE)
 328:	02 30       	cpi	r16, 0x02	; 2
 32a:	09 f0       	breq	.+2      	; 0x32e <PWM+0x184>
 32c:	09 c1       	rjmp	.+530    	; 0x540 <PWM+0x396>
			   	{
				   	TOGGLEBIT(PORTH,BIT(6));
 32e:	80 91 02 01 	lds	r24, 0x0102
 332:	90 e4       	ldi	r25, 0x40	; 64
 334:	89 27       	eor	r24, r25
 336:	f5 cf       	rjmp	.-22     	; 0x322 <PWM+0x178>
			   	}
		  }		
		else if(cy == 'B')
 338:	22 e4       	ldi	r18, 0x42	; 66
 33a:	b2 16       	cp	r11, r18
 33c:	e9 f4       	brne	.+58     	; 0x378 <PWM+0x1ce>
		  {
			   SETBIT(DDRE,BIT(4));
 33e:	6c 9a       	sbi	0x0d, 4	; 13
			   OCR3B = duty_cycle;
 340:	90 93 9b 00 	sts	0x009B, r25
 344:	80 93 9a 00 	sts	0x009A, r24
			   
			   	SETBIT(DDRL,BIT(7));
 348:	80 91 0a 01 	lds	r24, 0x010A
 34c:	80 68       	ori	r24, 0x80	; 128
 34e:	80 93 0a 01 	sts	0x010A, r24
			   	if (bit == CLEAR)
 352:	00 23       	and	r16, r16
 354:	21 f4       	brne	.+8      	; 0x35e <PWM+0x1b4>
			   	{
				   	CLEARBIT(PORTH,BIT(7));
 356:	80 91 02 01 	lds	r24, 0x0102
 35a:	8f 77       	andi	r24, 0x7F	; 127
 35c:	e2 cf       	rjmp	.-60     	; 0x322 <PWM+0x178>
			   	}
			   	else if (bit == SET)
 35e:	01 30       	cpi	r16, 0x01	; 1
 360:	21 f4       	brne	.+8      	; 0x36a <PWM+0x1c0>
			   	{
				   	SETBIT(PORTH,BIT(7));
 362:	80 91 02 01 	lds	r24, 0x0102
 366:	80 68       	ori	r24, 0x80	; 128
 368:	dc cf       	rjmp	.-72     	; 0x322 <PWM+0x178>
			   	}
			   	else if (bit == TOGGLE)
 36a:	02 30       	cpi	r16, 0x02	; 2
 36c:	09 f0       	breq	.+2      	; 0x370 <PWM+0x1c6>
 36e:	e8 c0       	rjmp	.+464    	; 0x540 <PWM+0x396>
			   	{
				   	TOGGLEBIT(PORTH,BIT(7));
 370:	80 91 02 01 	lds	r24, 0x0102
 374:	80 58       	subi	r24, 0x80	; 128
 376:	d5 cf       	rjmp	.-86     	; 0x322 <PWM+0x178>
			   	}
		  }
		else
		  {
			   SETBIT(DDRE,BIT(5));
 378:	6d 9a       	sbi	0x0d, 5	; 13
			   OCR3C = duty_cycle;
 37a:	90 93 9d 00 	sts	0x009D, r25
 37e:	80 93 9c 00 	sts	0x009C, r24
			   
		   		SETBIT(DDRG,BIT(3));
 382:	9b 9a       	sbi	0x13, 3	; 19
		   		if (bit == CLEAR)
 384:	00 23       	and	r16, r16
 386:	11 f4       	brne	.+4      	; 0x38c <PWM+0x1e2>
		   		{
			   		CLEARBIT(PORTG,BIT(3));
 388:	a3 98       	cbi	0x14, 3	; 20
 38a:	da c0       	rjmp	.+436    	; 0x540 <PWM+0x396>
		   		}
		   		else if (bit == SET)
 38c:	01 30       	cpi	r16, 0x01	; 1
 38e:	11 f4       	brne	.+4      	; 0x394 <PWM+0x1ea>
		   		{
			   		SETBIT(PORTG,BIT(3));
 390:	a3 9a       	sbi	0x14, 3	; 20
 392:	d6 c0       	rjmp	.+428    	; 0x540 <PWM+0x396>
		   		}
		   		else if (bit == TOGGLE)
 394:	02 30       	cpi	r16, 0x02	; 2
 396:	09 f0       	breq	.+2      	; 0x39a <PWM+0x1f0>
 398:	d3 c0       	rjmp	.+422    	; 0x540 <PWM+0x396>
		   		{
			   		TOGGLEBIT(PORTG,BIT(3));
 39a:	84 b3       	in	r24, 0x14	; 20
 39c:	98 e0       	ldi	r25, 0x08	; 8
 39e:	ce c0       	rjmp	.+412    	; 0x53c <PWM+0x392>
		   		}			   			   
		  }			  
	}

	if(ix == '4')
 3a0:	14 33       	cpi	r17, 0x34	; 52
 3a2:	09 f0       	breq	.+2      	; 0x3a6 <PWM+0x1fc>
 3a4:	6f c0       	rjmp	.+222    	; 0x484 <PWM+0x2da>
	{	
		ICR4 = frequency;
 3a6:	30 93 a7 00 	sts	0x00A7, r19
 3aa:	20 93 a6 00 	sts	0x00A6, r18
		duty_cycle = compute_duty_cycle(dc,ix);		
 3ae:	ce 01       	movw	r24, r28
 3b0:	64 e3       	ldi	r22, 0x34	; 52
 3b2:	0e 94 7e 00 	call	0xfc	; 0xfc <compute_duty_cycle>
 3b6:	9c 01       	movw	r18, r24
 		TCCR4A = 0xA8;
 3b8:	88 ea       	ldi	r24, 0xA8	; 168
 3ba:	80 93 a0 00 	sts	0x00A0, r24
		TCCR4B = 0x11;
 3be:	81 e1       	ldi	r24, 0x11	; 17
 3c0:	80 93 a1 00 	sts	0x00A1, r24
		if(cy == 'A')
 3c4:	81 e4       	ldi	r24, 0x41	; 65
 3c6:	b8 16       	cp	r11, r24
 3c8:	c1 f4       	brne	.+48     	; 0x3fa <PWM+0x250>
		  { 
			SETBIT(DDRH,BIT(3));
 3ca:	80 91 01 01 	lds	r24, 0x0101
 3ce:	88 60       	ori	r24, 0x08	; 8
 3d0:	80 93 01 01 	sts	0x0101, r24
			OCR4A = duty_cycle;
 3d4:	30 93 a9 00 	sts	0x00A9, r19
 3d8:	20 93 a8 00 	sts	0x00A8, r18
			
				SETBIT(DDRG,BIT(4));
 3dc:	9c 9a       	sbi	0x13, 4	; 19
				if (bit == CLEAR)
 3de:	00 23       	and	r16, r16
 3e0:	11 f4       	brne	.+4      	; 0x3e6 <PWM+0x23c>
				{
					CLEARBIT(PORTG,BIT(4));
 3e2:	a4 98       	cbi	0x14, 4	; 20
 3e4:	ad c0       	rjmp	.+346    	; 0x540 <PWM+0x396>
				}
				else if (bit == SET)
 3e6:	01 30       	cpi	r16, 0x01	; 1
 3e8:	11 f4       	brne	.+4      	; 0x3ee <PWM+0x244>
				{
					SETBIT(PORTG,BIT(4));
 3ea:	a4 9a       	sbi	0x14, 4	; 20
 3ec:	a9 c0       	rjmp	.+338    	; 0x540 <PWM+0x396>
				}
				else if (bit == TOGGLE)
 3ee:	02 30       	cpi	r16, 0x02	; 2
 3f0:	09 f0       	breq	.+2      	; 0x3f4 <PWM+0x24a>
 3f2:	a6 c0       	rjmp	.+332    	; 0x540 <PWM+0x396>
				{
					TOGGLEBIT(PORTG,BIT(4));
 3f4:	84 b3       	in	r24, 0x14	; 20
 3f6:	90 e1       	ldi	r25, 0x10	; 16
 3f8:	a1 c0       	rjmp	.+322    	; 0x53c <PWM+0x392>
				}
		  }		
		else if(cy == 'B')
 3fa:	82 e4       	ldi	r24, 0x42	; 66
 3fc:	b8 16       	cp	r11, r24
 3fe:	09 f5       	brne	.+66     	; 0x442 <PWM+0x298>
		  {
			SETBIT(DDRH,BIT(4));
 400:	80 91 01 01 	lds	r24, 0x0101
 404:	80 61       	ori	r24, 0x10	; 16
 406:	80 93 01 01 	sts	0x0101, r24
		   OCR4B = duty_cycle;
 40a:	30 93 ab 00 	sts	0x00AB, r19
 40e:	20 93 aa 00 	sts	0x00AA, r18
		   
		   		SETBIT(DDRL,BIT(0));
 412:	80 91 0a 01 	lds	r24, 0x010A
 416:	81 60       	ori	r24, 0x01	; 1
 418:	80 93 0a 01 	sts	0x010A, r24
		   		if (bit == CLEAR)
 41c:	00 23       	and	r16, r16
 41e:	21 f4       	brne	.+8      	; 0x428 <PWM+0x27e>
		   		{
			   		CLEARBIT(PORTL,BIT(0));
 420:	80 91 0b 01 	lds	r24, 0x010B
 424:	8e 7f       	andi	r24, 0xFE	; 254
 426:	0c cf       	rjmp	.-488    	; 0x240 <PWM+0x96>
		   		}
		   		else if (bit == SET)
 428:	01 30       	cpi	r16, 0x01	; 1
 42a:	21 f4       	brne	.+8      	; 0x434 <PWM+0x28a>
		   		{
			   		SETBIT(PORTL,BIT(0));
 42c:	80 91 0b 01 	lds	r24, 0x010B
 430:	81 60       	ori	r24, 0x01	; 1
 432:	06 cf       	rjmp	.-500    	; 0x240 <PWM+0x96>
		   		}
		   		else if (bit == TOGGLE)
 434:	02 30       	cpi	r16, 0x02	; 2
 436:	09 f0       	breq	.+2      	; 0x43a <PWM+0x290>
 438:	83 c0       	rjmp	.+262    	; 0x540 <PWM+0x396>
		   		{
			   		TOGGLEBIT(PORTL,BIT(0));
 43a:	80 91 0b 01 	lds	r24, 0x010B
 43e:	91 e0       	ldi	r25, 0x01	; 1
 440:	28 cf       	rjmp	.-432    	; 0x292 <PWM+0xe8>
		   		}
		  }
		else
		  {
			  SETBIT(DDRH,BIT(5));
 442:	80 91 01 01 	lds	r24, 0x0101
 446:	80 62       	ori	r24, 0x20	; 32
 448:	80 93 01 01 	sts	0x0101, r24
		      OCR4C = duty_cycle;
 44c:	30 93 ad 00 	sts	0x00AD, r19
 450:	20 93 ac 00 	sts	0x00AC, r18
			  
			  	SETBIT(DDRL,BIT(1));
 454:	80 91 0a 01 	lds	r24, 0x010A
 458:	82 60       	ori	r24, 0x02	; 2
 45a:	80 93 0a 01 	sts	0x010A, r24
			  	if (bit == CLEAR)
 45e:	00 23       	and	r16, r16
 460:	21 f4       	brne	.+8      	; 0x46a <PWM+0x2c0>
			  	{
				  	CLEARBIT(PORTL,BIT(1));
 462:	80 91 0b 01 	lds	r24, 0x010B
 466:	8d 7f       	andi	r24, 0xFD	; 253
 468:	eb ce       	rjmp	.-554    	; 0x240 <PWM+0x96>
			  	}
			  	else if (bit == SET)
 46a:	01 30       	cpi	r16, 0x01	; 1
 46c:	21 f4       	brne	.+8      	; 0x476 <PWM+0x2cc>
			  	{
				  	SETBIT(PORTL,BIT(1));
 46e:	80 91 0b 01 	lds	r24, 0x010B
 472:	82 60       	ori	r24, 0x02	; 2
 474:	e5 ce       	rjmp	.-566    	; 0x240 <PWM+0x96>
			  	}
			  	else if (bit == TOGGLE)
 476:	02 30       	cpi	r16, 0x02	; 2
 478:	09 f0       	breq	.+2      	; 0x47c <PWM+0x2d2>
 47a:	62 c0       	rjmp	.+196    	; 0x540 <PWM+0x396>
			  	{
				  	TOGGLEBIT(PORTL,BIT(1));
 47c:	80 91 0b 01 	lds	r24, 0x010B
 480:	80 27       	eor	r24, r16
 482:	de ce       	rjmp	.-580    	; 0x240 <PWM+0x96>
			  	}
		  }		  
	}

	if(ix == '5')
 484:	15 33       	cpi	r17, 0x35	; 53
 486:	09 f0       	breq	.+2      	; 0x48a <PWM+0x2e0>
 488:	5b c0       	rjmp	.+182    	; 0x540 <PWM+0x396>
	{
		ICR5 = frequency;
 48a:	30 93 27 01 	sts	0x0127, r19
 48e:	20 93 26 01 	sts	0x0126, r18
		duty_cycle = compute_duty_cycle(dc,ix);
 492:	ce 01       	movw	r24, r28
 494:	65 e3       	ldi	r22, 0x35	; 53
 496:	0e 94 7e 00 	call	0xfc	; 0xfc <compute_duty_cycle>
 49a:	9c 01       	movw	r18, r24
 		TCCR5A = 0xA8;
 49c:	88 ea       	ldi	r24, 0xA8	; 168
 49e:	80 93 20 01 	sts	0x0120, r24
		TCCR5B = 0x11;
 4a2:	81 e1       	ldi	r24, 0x11	; 17
 4a4:	80 93 21 01 	sts	0x0121, r24
		if(cy == 'A')
 4a8:	81 e4       	ldi	r24, 0x41	; 65
 4aa:	b8 16       	cp	r11, r24
 4ac:	b9 f4       	brne	.+46     	; 0x4dc <PWM+0x332>
		  { 
			SETBIT(DDRL,BIT(3));
 4ae:	80 91 0a 01 	lds	r24, 0x010A
 4b2:	88 60       	ori	r24, 0x08	; 8
 4b4:	80 93 0a 01 	sts	0x010A, r24
		   OCR5A = duty_cycle;
 4b8:	30 93 29 01 	sts	0x0129, r19
 4bc:	20 93 28 01 	sts	0x0128, r18
		   
		   	SETBIT(DDRG,BIT(0));
 4c0:	98 9a       	sbi	0x13, 0	; 19
		   	if (bit == CLEAR)
 4c2:	00 23       	and	r16, r16
 4c4:	11 f4       	brne	.+4      	; 0x4ca <PWM+0x320>
		   	{
			   	CLEARBIT(PORTG,BIT(0));
 4c6:	a0 98       	cbi	0x14, 0	; 20
 4c8:	3b c0       	rjmp	.+118    	; 0x540 <PWM+0x396>
		   	}
		   	else if (bit == SET)
 4ca:	01 30       	cpi	r16, 0x01	; 1
 4cc:	11 f4       	brne	.+4      	; 0x4d2 <PWM+0x328>
		   	{
			   	SETBIT(PORTG,BIT(0));
 4ce:	a0 9a       	sbi	0x14, 0	; 20
 4d0:	37 c0       	rjmp	.+110    	; 0x540 <PWM+0x396>
		   	}
		   	else if (bit == TOGGLE)
 4d2:	02 30       	cpi	r16, 0x02	; 2
 4d4:	a9 f5       	brne	.+106    	; 0x540 <PWM+0x396>
		   	{
			   	TOGGLEBIT(PORTG,BIT(0));
 4d6:	84 b3       	in	r24, 0x14	; 20
 4d8:	91 e0       	ldi	r25, 0x01	; 1
 4da:	30 c0       	rjmp	.+96     	; 0x53c <PWM+0x392>
		   	}
		  }		
		else if(cy == 'B')
 4dc:	82 e4       	ldi	r24, 0x42	; 66
 4de:	b8 16       	cp	r11, r24
 4e0:	b9 f4       	brne	.+46     	; 0x510 <PWM+0x366>
		  {
			  SETBIT(DDRL,BIT(4));
 4e2:	80 91 0a 01 	lds	r24, 0x010A
 4e6:	80 61       	ori	r24, 0x10	; 16
 4e8:	80 93 0a 01 	sts	0x010A, r24
		   OCR5B = duty_cycle;
 4ec:	30 93 2b 01 	sts	0x012B, r19
 4f0:	20 93 2a 01 	sts	0x012A, r18
		   
		   			  	SETBIT(DDRG,BIT(1));
 4f4:	99 9a       	sbi	0x13, 1	; 19
		   			  	if (bit == CLEAR)
 4f6:	00 23       	and	r16, r16
 4f8:	11 f4       	brne	.+4      	; 0x4fe <PWM+0x354>
		   			  	{
			   			  	CLEARBIT(PORTG,BIT(1));
 4fa:	a1 98       	cbi	0x14, 1	; 20
 4fc:	21 c0       	rjmp	.+66     	; 0x540 <PWM+0x396>
		   			  	}
		   			  	else if (bit == SET)
 4fe:	01 30       	cpi	r16, 0x01	; 1
 500:	11 f4       	brne	.+4      	; 0x506 <PWM+0x35c>
		   			  	{
			   			  	SETBIT(PORTG,BIT(1));
 502:	a1 9a       	sbi	0x14, 1	; 20
 504:	1d c0       	rjmp	.+58     	; 0x540 <PWM+0x396>
		   			  	}
		   			  	else if (bit == TOGGLE)
 506:	02 30       	cpi	r16, 0x02	; 2
 508:	d9 f4       	brne	.+54     	; 0x540 <PWM+0x396>
		   			  	{
			   			  	TOGGLEBIT(PORTG,BIT(1));
 50a:	84 b3       	in	r24, 0x14	; 20
 50c:	80 27       	eor	r24, r16
 50e:	17 c0       	rjmp	.+46     	; 0x53e <PWM+0x394>
		   			  	}
		  }
		else
		  {
			  SETBIT(DDRL,BIT(5));
 510:	80 91 0a 01 	lds	r24, 0x010A
 514:	80 62       	ori	r24, 0x20	; 32
 516:	80 93 0a 01 	sts	0x010A, r24
			  OCR5C = duty_cycle;
 51a:	30 93 2d 01 	sts	0x012D, r19
 51e:	20 93 2c 01 	sts	0x012C, r18
			  
			  	SETBIT(DDRG,BIT(2));
 522:	9a 9a       	sbi	0x13, 2	; 19
			  	if (bit == CLEAR)
 524:	00 23       	and	r16, r16
 526:	11 f4       	brne	.+4      	; 0x52c <PWM+0x382>
			  	{
				  	CLEARBIT(PORTG,BIT(2));
 528:	a2 98       	cbi	0x14, 2	; 20
 52a:	0a c0       	rjmp	.+20     	; 0x540 <PWM+0x396>
			  	}
			  	else if (bit == SET)
 52c:	01 30       	cpi	r16, 0x01	; 1
 52e:	11 f4       	brne	.+4      	; 0x534 <PWM+0x38a>
			  	{
				  	SETBIT(PORTG,BIT(2));
 530:	a2 9a       	sbi	0x14, 2	; 20
 532:	06 c0       	rjmp	.+12     	; 0x540 <PWM+0x396>
			  	}
			  	else if (bit == TOGGLE)
 534:	02 30       	cpi	r16, 0x02	; 2
 536:	21 f4       	brne	.+8      	; 0x540 <PWM+0x396>
			  	{
				  	TOGGLEBIT(PORTG,BIT(2));
 538:	84 b3       	in	r24, 0x14	; 20
 53a:	94 e0       	ldi	r25, 0x04	; 4
 53c:	89 27       	eor	r24, r25
 53e:	84 bb       	out	0x14, r24	; 20
			  	}
		  }	
	}

}
 540:	df 91       	pop	r29
 542:	cf 91       	pop	r28
 544:	1f 91       	pop	r17
 546:	0f 91       	pop	r16
 548:	ff 90       	pop	r15
 54a:	ef 90       	pop	r14
 54c:	df 90       	pop	r13
 54e:	cf 90       	pop	r12
 550:	bf 90       	pop	r11
 552:	08 95       	ret

00000554 <__udivmodhi4>:
 554:	aa 1b       	sub	r26, r26
 556:	bb 1b       	sub	r27, r27
 558:	51 e1       	ldi	r21, 0x11	; 17
 55a:	07 c0       	rjmp	.+14     	; 0x56a <__udivmodhi4_ep>

0000055c <__udivmodhi4_loop>:
 55c:	aa 1f       	adc	r26, r26
 55e:	bb 1f       	adc	r27, r27
 560:	a6 17       	cp	r26, r22
 562:	b7 07       	cpc	r27, r23
 564:	10 f0       	brcs	.+4      	; 0x56a <__udivmodhi4_ep>
 566:	a6 1b       	sub	r26, r22
 568:	b7 0b       	sbc	r27, r23

0000056a <__udivmodhi4_ep>:
 56a:	88 1f       	adc	r24, r24
 56c:	99 1f       	adc	r25, r25
 56e:	5a 95       	dec	r21
 570:	a9 f7       	brne	.-22     	; 0x55c <__udivmodhi4_loop>
 572:	80 95       	com	r24
 574:	90 95       	com	r25
 576:	bc 01       	movw	r22, r24
 578:	cd 01       	movw	r24, r26
 57a:	08 95       	ret

0000057c <__udivmodsi4>:
 57c:	a1 e2       	ldi	r26, 0x21	; 33
 57e:	1a 2e       	mov	r1, r26
 580:	aa 1b       	sub	r26, r26
 582:	bb 1b       	sub	r27, r27
 584:	fd 01       	movw	r30, r26
 586:	0d c0       	rjmp	.+26     	; 0x5a2 <__udivmodsi4_ep>

00000588 <__udivmodsi4_loop>:
 588:	aa 1f       	adc	r26, r26
 58a:	bb 1f       	adc	r27, r27
 58c:	ee 1f       	adc	r30, r30
 58e:	ff 1f       	adc	r31, r31
 590:	a2 17       	cp	r26, r18
 592:	b3 07       	cpc	r27, r19
 594:	e4 07       	cpc	r30, r20
 596:	f5 07       	cpc	r31, r21
 598:	20 f0       	brcs	.+8      	; 0x5a2 <__udivmodsi4_ep>
 59a:	a2 1b       	sub	r26, r18
 59c:	b3 0b       	sbc	r27, r19
 59e:	e4 0b       	sbc	r30, r20
 5a0:	f5 0b       	sbc	r31, r21

000005a2 <__udivmodsi4_ep>:
 5a2:	66 1f       	adc	r22, r22
 5a4:	77 1f       	adc	r23, r23
 5a6:	88 1f       	adc	r24, r24
 5a8:	99 1f       	adc	r25, r25
 5aa:	1a 94       	dec	r1
 5ac:	69 f7       	brne	.-38     	; 0x588 <__udivmodsi4_loop>
 5ae:	60 95       	com	r22
 5b0:	70 95       	com	r23
 5b2:	80 95       	com	r24
 5b4:	90 95       	com	r25
 5b6:	9b 01       	movw	r18, r22
 5b8:	ac 01       	movw	r20, r24
 5ba:	bd 01       	movw	r22, r26
 5bc:	cf 01       	movw	r24, r30
 5be:	08 95       	ret

000005c0 <toupper>:
 5c0:	91 11       	cpse	r25, r1
 5c2:	08 95       	ret
 5c4:	81 56       	subi	r24, 0x61	; 97
 5c6:	8a 51       	subi	r24, 0x1A	; 26
 5c8:	08 f4       	brcc	.+2      	; 0x5cc <toupper+0xc>
 5ca:	80 52       	subi	r24, 0x20	; 32
 5cc:	85 58       	subi	r24, 0x85	; 133
 5ce:	08 95       	ret

000005d0 <_exit>:
 5d0:	f8 94       	cli

000005d2 <__stop_program>:
 5d2:	ff cf       	rjmp	.-2      	; 0x5d2 <__stop_program>
